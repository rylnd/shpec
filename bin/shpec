#
: Use one of: bash, dash, or ksh93

indent() {
  printf '%*s' $(( (test_indent - 1) * 2))
}

# 'echo -e' is not a POSIX feature.
# This helps us to work around that.
echo_needs_minus_e(){
  echo "\010"| (read a; [ ${#a} -ne 1 ])
}

if echo_needs_minus_e; then
  echoe() { echo -e "$@"; }
else
  echoe() { echo "$@"; }
fi

iecho() {
  indent && echoe "$@"
}

sanitize() {
  IFS= echoe "$1" | tr '\n' 'n' | tr "'" 'q'
}

describe() {
  : $((test_indent += 1))
  iecho "$1"
}

end() {
  : $((test_indent -=1 ))
  if [ $test_indent -eq 0 ]; then
    [ $failures -eq 0 ]
  fi
}

end_describe() {
  iecho "Warning: end_describe will be deprecated in shpec 1.0." \
    "Please use end instead."
  end
}

# Beware: POSIX shells are not required to accept
# any identifier as a function name.

stub_command() {
  body="${2:-:}"
  eval "$1() { $body; }"
}

unstub_command() { unset -f "$1"; }

it() {
  : $((test_indent += 1))
  : $((examples += 1))
  assertion="$1"
}

assert() {
  case "x$1" in
  xequal )
    print_result "[ '$(sanitize "$2")' = '$(sanitize "$3")' ]" \
      "Expected [$2] to equal [$3]"
  ;;
  xunequal )
    print_result "[ '$(sanitize "$2")' != '$(sanitize "$3")' ]" \
      "Expected [$2] not to equal [$3]"
  ;;
  xgt )
    print_result "[ $2 -gt $3 ]" \
      "Expected [$2] to be > [$3]"
  ;;
  xlt )
    print_result "[ $2 -lt $3 ]" \
      "Expected [$2] to be < [$3]"
  ;;
  xmatch )
    print_result "case '$2' in *$3*) :;; *) false;; esac" \
      "Expected [$2] to match [$3]"
  ;;
  xno_match )
    print_result "case '$2' in *$3*) false ;; *) :;; esac" \
      "Expected [$2] not to match [$3]"
  ;;
  xpresent )
    print_result "[ -n '$2' ]" \
      "Expected [$2] to be present"
  ;;
  xblank )
    print_result "[ -z '$2' ]" \
      "Expected [$2] to be blank"
  ;;

  xfile_present )
    print_result "[ -e $2 ]" \
      "Expected file [$2] to exist"
  ;;
  xfile_absent )
    print_result "[ ! -e $2 ]" \
      "Expected file [$2] not to exist"
  ;;
  xsymlink )
    link="$(readlink $2)"
    print_result "[ '$link' = '$3' ]" \
      "Expected [$2] to link to [$3], but got [$link]"
  ;;
  xtest )
    print_result "$2" \
      "Expected $2 to be true"
  ;;
  * )
    if type "$1" 2>/dev/null | grep -q 'function'; then
      matcher="$1"; shift
      $matcher "$@"
    else
      print_result false "Error: Unknown matcher [$1]"
    fi
  ;;
  esac
}

print_result() {
  if eval "$1"; then
    iecho "$green$assertion$norm"
  else
    : $((failures += 1))
    iecho "$red$assertion"
    iecho "($2)$norm"
  fi
}


shpec() {
  (
  VERSION=0.1.2posix
  examples=0
  failures=0
  test_indent=0
  red="\033[0;31m"
  green="\033[0;32m"
  norm="\033[0m"

  SHPEC_ROOT=${SHPEC_ROOT:-$([ -d './shpec' ] && echo './shpec' || echo '.')}
  case "$1" in
  ( -v | --version ) echo "$VERSION"
  ;;
  ( * )
      matcher_files="$(
          find "$SHPEC_ROOT/matchers" -name '*.sh' 2>/dev/null
      )"

      for matcher_file in $matcher_files; do
        . "$matcher_file"
      done

      if [ $# -gt 0 ] ; then
        : \$1="'$1'" \${#1}="'${#1}'"
        files="${@}"
      else
        files=$(
          find $SHPEC_ROOT -name '*_shpec.sh'
        )
      fi

      for file in $files; do
        echo >& 2 "$file"
        . "$file" || exit
      done

      [ $failures -eq 0 ] && color=$green || color=$red
      echoe "${color}${examples} examples, ${failures} failures${norm}"

      times
      [ $failures -eq 0 ]
      exit
  ;;
  esac
  )
}

(
  _progname=shpec
  _pathname=$( command -v $0 )
  _cmdname=${_pathname##*/}
  _main=shpec

  case $_progname in (${_cmdname%.sh}) $_main "$@";; esac
)
