# vim: set ft=sh:

indent() {
  printf '%*s' $(( (test_indent - 1) * 2))
}

# 'echo -e' is not a POSIX feature.
# This helps us to work around that.
echo_needs_minus_e(){
  echo "\010"| (read a; [ ${#a} -ne 1 ])
}

if echo_needs_minus_e; then
  echoe() { echo -e "$@"; }
else
  echoe() { echo "$@"; }
fi

iecho() {
  indent && echoe "$@"
}

sanitize() {
  IFS= echoe "$1" | tr '\n' 'n' | tr "'" 'q'
}

describe() {
  : $((test_indent += 1))
  iecho "$1"
}

end() {
  : $((test_indent -= 1))
  if [ $test_indent -eq 0 ]; then
    [ $failures -eq 0 ]
  fi
}

end_describe() {
  iecho "Warning: end_describe will be deprecated in shpec 1.0." \
    "Please use end instead."
  end
}

# Beware: POSIX shells are not required to accept
# any identifier as a function name.

stub_command() {
  body="${2:-:}"
  eval "$1() { $body; }"
}

unstub_command() { unset -f "$1"; }

it() {
  : $((test_indent += 1))
  : $((examples += 1))
  assertion="$1"
}

is_function() {
  case $(type "$1" 2> /dev/null) in
    (*function*) return 0;;
  esac
  return 1
}

assert() {
  case "x$1" in
  ( xequal )
    print_result "[ '$(sanitize "$2")' = '$(sanitize "$3")' ]" \
      "Expected [$2] to equal [$3]"
  ;;
  ( xunequal )
    print_result "[ '$(sanitize "$2")' != '$(sanitize "$3")' ]" \
      "Expected [$2] not to equal [$3]"
  ;;
  ( xgt )
    print_result "[ $2 -gt $3 ]" \
      "Expected [$2] to be > [$3]"
  ;;
  ( xlt )
    print_result "[ $2 -lt $3 ]" \
      "Expected [$2] to be < [$3]"
  ;;
  ( xmatch )
    print_result "case '$2' in *$3*) :;; *) false;; esac" \
      "Expected [$2] to match [$3]"
  ;;
  ( xno_match )
    print_result "case '$2' in *$3*) false ;; *) :;; esac" \
      "Expected [$2] not to match [$3]"
  ;;
  ( xpresent )
    print_result "[ -n '$2' ]" \
      "Expected [$2] to be present"
  ;;
  ( xblank )
    print_result "[ -z '$2' ]" \
      "Expected [$2] to be blank"
  ;;

  ( xfile_present )
    print_result "[ -e $2 ]" \
      "Expected file [$2] to exist"
  ;;
  ( xfile_absent )
    print_result "[ ! -e $2 ]" \
      "Expected file [$2] not to exist"
  ;;
  ( xsymlink )
    link="$(readlink $2)"
    print_result "[ '$link' = '$3' ]" \
      "Expected [$2] to link to [$3], but got [$link]"
  ;;
  ( xtest )
    print_result "$2" \
      "Expected $2 to be true"
  ;;
  ( * )
    if is_function "$1"; then
      matcher="$1"; shift
      $matcher "$@"
      return 0
    else
      print_result false "Error: Unknown matcher [$1]"
    fi
  ;;
  esac
}

print_result() {
  if eval "$1"; then
    iecho "$green$assertion$norm"
  else
    : $((failures += 1))
    iecho "$red$assertion"
    iecho "($2)$norm"
  fi
}

final_results() {
  [ $failures -eq 0 ] && color=$green || color=$red
  echoe "${color}${examples} examples, ${failures} failures${norm}"
  times
  [ $failures -eq 0 ]
  exit
}


shpec() {
  (
    VERSION=0.3.0
    case "$1" in
    ( -v | --version )
      echo "$VERSION"
      exit 0
    ;;
    esac

    examples=0
    failures=0
    test_indent=0
    red="\033[0;31m"
    green="\033[0;32m"
    norm="\033[0m"

    SHPEC_ROOT=${SHPEC_ROOT:-$(
      [ -d './shpec' ] && echo './shpec' || echo '.'
    )}

    matcher_files=$(
      find "$SHPEC_ROOT/matchers" -name '*.sh' 2>/dev/null
    )

    for matcher_file in $matcher_files; do
      . "$matcher_file"
    done

    if [ $# -gt 0 ] ; then
      files="${@}"
    else
      files=$(
        find $SHPEC_ROOT -name '*_shpec.sh'
      )
    fi

    for file in $files; do
      . "$file"
    done

    final_results
  )
}

(
  _progname=shpec
  _pathname=$( command -v $0 )
  _cmdname=${_pathname##*/}
  _main=shpec

  case $_progname in (${_cmdname%.sh}) $_main "$@";; esac
)
